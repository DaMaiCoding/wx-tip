# 微信消息防撤回功能技术方案 (v2.0)

## 1. 方案概述
本方案采用非注入式（UI Automation）技术，通过建立微信会话的“本地影子信箱（Shadow Inbox）”，实现对撤回消息的捕获与还原。系统不修改微信客户端任何文件，安全且低风险。

## 2. 核心架构：影子信箱 (Shadow Inbox)
为了解决微信原生不再显示被撤回消息内容的问题，系统在本地内存中维护一份独立的消息历史记录。

### 2.1 数据结构
系统维护一个全局哈希表 `$global:shadowInbox`：
*   **Key**: `ChatName` (聊天对象名称，如 "文件传输助手")
*   **Value**: `List<PSCustomObject>` (消息历史队列)
    *   **Capacity**: 每个会话保留最近 **50** 条消息（滚动覆盖）。
    *   **Item Structure**:
        ```powershell
        [PSCustomObject]@{
            content   = "消息文本内容"
            timestamp = "HH:mm:ss"
            type      = "Text"  # 扩展字段
        }
        ```

### 2.2 数据同步机制 (Active Sync)
为了确保“影子信箱”即使在未实时监控时也能获取历史数据，系统实现了**主动窗口同步**策略：
1.  **触发时机**：当用户点击侧边栏切换会话，或聊天窗口被激活时。
2.  **抓取逻辑**：
    *   使用 `UIAutomation` 扫描当前聊天窗口可视区域的所有 `ListItem`。
    *   提取所有非系统提示的文本消息。
    *   **合并算法**：将可视区域的消息与本地 `shadowInbox` 进行比对。
        *   如果本地为空，全量存入。
        *   如果本地已有数据，尝试找到重叠部分（Overlap），仅追加新消息，防止重复。

## 3. 撤回检测流程
系统采用双重检测机制，分别应对“秒撤”和“历史撤回”。

### 3.1 场景一：最新消息即时撤回 (Sidebar Monitoring)
这是最常见的场景，对方发送消息后立即撤回。
*   **触发条件**：监控程序检测到侧边栏（Sidebar）显示的最后一条消息内容变为“"xxx" 撤回了一条消息”。
*   **处理逻辑**：
    1.  系统立即读取 `shadowInbox` 中该会话的**最后一条消息**。
    2.  如果该消息存在且未被标记为已处理，则判定为被撤回的内容。
    3.  触发撤回通知。

### 3.2 场景二：历史消息延迟撤回 (Deep Scan & Context Backtracking)
对方撤回了非最新的一条消息（中间的消息），此时侧边栏预览可能不会变化。
*   **触发条件**：
    *   用户切换聊天会话。
    *   聊天窗口获得焦点。
    *   定时深度扫描（冷却时间 2秒）。
*   **定位算法 (Context Anchor Matching)**：
    当在屏幕可视区域扫描到“撤回了一条消息”的系统提示时，系统利用**上下文锚点**在 `shadowInbox` 中定位原消息：
    1.  **获取锚点**：
        *   **Next Anchor (后向锚点)**：撤回提示下方的第一条正常消息。
        *   **Prev Anchor (前向锚点)**：撤回提示上方的第一条正常消息。
    2.  **回溯查找**：
        *   **策略 A (Next优先)**：在历史记录中查找 `Next Anchor` 的内容。如果找到索引 `i`，则被撤回的消息应该是 `i-1`。
        *   **策略 B (Prev兜底)**：如果策略 A 失败，在历史记录中查找 `Prev Anchor` 的内容。如果找到索引 `j`，则被撤回的消息应该是 `j+1`。

## 4. 去重与防抖 (De-duplication)
为了防止用户反复查看同一条撤回提示导致系统重复报警，引入全局去重机制。

### 4.1 全局记录表
*   变量：`$global:processedRecalls` (HashSet)
*   **指纹格式**：`"{ChatName}|{RecallContent}"`
    *   例如：`"张三|你好，这是被撤回的消息"`

### 4.2 拦截逻辑
*   **写入前检查**：每次准备发送撤回通知前，计算指纹。
*   **判断**：如果指纹已存在于 `processedRecalls`，则直接**丢弃**，不发送通知，不写入日志。
*   **持久化**：指纹记录在内存中，随服务重启而重置。

## 5. 交互设计
*   **实时通知**：通过标准输出 (STDOUT) 输出 JSON 格式事件，由上层应用（Electron/Node.js）消费并展示通知。
    ```json
    {
      "type": "recall",
      "title": "文件传输助手",
      "content": "检测到撤回: 刚才发错了",
      "originalContent": "刚才发错了",
      "timestamp": "10:30:05"
    }
    ```
*   **日志记录**：关键操作（如同步、匹配、检测）均写入 `debug.log` 便于排查。

## 6. 方案优势
*   **零侵入**：完全基于 UI 视觉识别，无封号风险。
*   **全场景覆盖**：
    *   支持**即时撤回**（秒撤）。
    *   支持**延迟撤回**（查看历史记录时发现的撤回）。
    *   支持**上下文回溯**（即使撤回的不是最后一条也能找回）。
*   **智能去重**：避免重复打扰用户。
